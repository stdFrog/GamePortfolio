#pragma once

/*
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	선형대수에서 선형성은 예측/계산 가능한 비례 관계를 말한다.
	평면에서 이러한 성질을 가진 직선은 다음과 같은 조건을 만족한다.

	좌변은 f(x1 + x2) = f(x1) + f(x2)	: 가법성
	우변은 f(k * x) = k * f(x)			: 1차 동차성

	이 둘은 선형성을 만족하는가를 판단할 때 즉, 명제를 증명할 때 사용된다.

	예로, y = ax의 그래프를 떠올려보자.
	이 직선은 f(x) = ax의 함수로 볼 수 있다. 이 함수의 인자로 x1 + x2를 대입한 후 
	좌변과 우변의 결과가 서로 같다면 가법성을 만족한다고 할 수 있다.

	또, k * x를 대입하여 좌변과 우변이 서로 같다면 1차 동차성을 만족한다고 할 수 있다.

	적용해보면 다음과 같다.
	좌변 : f(x1 + x2) = a(x1 + x2)
	우변 : f(x1) + f(x2) = ax1 + ax2
	====================================================================================
	좌변 : f(k * x) = a(k * x)
	우변 : k * f(x) = k * (a * x)

	이러한 함수를 선형 함수라고 한다.
	흔히 아는 y = x^2, y = x^3과 같이 우함수 또는 기함수 등을 떠올리면 된다.
	단, y = ax + b와 같이 bias(절편)를 가진 함수는 이러한 조건을 만족하지 못한다.

	따라서 선형성을 가진 직선은 원점을 지난다는 특징을 가지며 순수한 비(ratio)로 구성된 1차적 대응 관계를 의미한다.
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	이제 단순한 직선이 아닌 평면을 떠올려보자.
	평면은 직선(수직선) 두 개가 서로 수직하여 나타내는 공간을 말한다.
	
	곧, 두 개의 원소로 이루어진 공간이라는 뜻이며 이 원소를 x와 y로 표현한다.
	
	이처럼 단순한 직선에서 평면으로 그 영역을 넓힐 때, 공간(또는 차원)을 확장했다고 한다.
	이게 가능한 이유는 곱집합의 성질 때문이다.
	
	곱집합(Cartesian Product)이란, 데카르트 곱이라고도 부르는데 컴퓨터 활용 능력 등의 자격증을 공부할 때
	자주 나오는 용어라 대부분 익숙할 것이다. 

	두 집합(A,B)에서 하나의 원소(a,b)씩 짝지어 쌍으로 표현할 때 이를 곱집합(A X B)의 원소로 본다.
	-> A X B = {(a,b) | a∈A, b∈B}

	쉽게 비유하자면, 엑셀의 행(y)과 열(x)은 집합이고 그 순서는 각 집합의 원소이다.
	
	곱집합 전체는 곧, 집합의 원소를 순서대로 묶은 것과 같으며 행과 열처럼 두 집합을 서로 수직하여 배치한다.
	따라서 x와 y 즉, 두 원소는 서로 독립적인 집합이지만, 서로 곱하여 하나의 집합으로 표현될 수 있다.

	이를 평면에서 점 P(x,y)로 나타낸다. 
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	이제 벡터 공간에 대해 알아보자.
	
	평면은 두 실수가 결합(쌍)해 만들어진 것이며, 이는 곧 곱집합으로 생성된 새로운 집합이다.
	이를 공리적 집합론의 관점에서 규정한 것을 벡터 공간이라고 부른다.

	이 공간의 원소를 벡터(Vector)라고 하며, 실수의 연산 성질에 따라 체의 구조를 가지는 수를 스칼라(Scalar)라고 부른다.
	평면은 두 실수가 결합해 만들어진 것이므로 큰 의미에서 스칼라의 집합이라고 볼 수 있다.

	깐깐한 수학자들의 이론에 따르면 서로 완전히 같지는 않다고 한다.
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	다시 돌아와서 선형성을 가지는 함수와 벡터 공간의 관계를 살펴보자.

	앞서 말했듯, 벡터 공간은 두 개의 원소로 이루어진 공간이다.
	이 원소는 서로 독립된 집합(A,B)이며 이 두 집합의 원소(a,b)가 서로 묶여 표현될 때 벡터 공간의 한 점을 이룬다.

	이때 점을 이루는 원소(a,b)가 각각 선형성을 유지한다면, 즉 단순한 비의 형태로 구성된다면,
	이를 묶어 표현한 벡터 공간의 한 점 역시 동일한 비를 가진 형태일 것이다.

	그렇다면, 이 공간에서 어떠한 연산을 필요로 할 때 각 원소가 선형성을 유지할 수 있게끔 만든다면,
	어떠한 연산이든 그 결과를 쉽게 예측할 수 있을 것이다.

	이를 위해 수학자들이 개발한 도구가 있었으니, 그게 바로 행렬이다.
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	행렬은 벡터 공간에서 각 원소가 선형성을 유지할 수 있게끔 돕는 도구라고 했다.
	
	이는 곧, 선형 변환의 계산 과정을 체계화시킨 일종의 함수 정도로 볼 수 있다.
	행렬의 연산은 그 과정이 꽤 복잡하기 때문에 직접 찾아보고 이해해두는 것이 좋으며,
	3차원 수학을 필요로 하는 시점이라면 사원수에 대해서도 알아보기 바란다.

	여기까지 기본적인 용어와 이론에 대해 정리해봤다.
*/

const int DIMENSION = 3;

class Matrix
{
	// 모델링 행렬은 나중에 추가해보자.
public:
	std::array<Vector, DIMENSION> Columns = {
		Vector::UnitX,
		Vector::UnitY,
		Vector::UnitZ
	};

	Matrix(
		const Vector& v1 = Vector::UnitX,
		const Vector& v2 = Vector::UnitY,
		const Vector& v3 = Vector::UnitZ
	) {
		Columns = { v1, v2, v3 };
	}

	Vector& operator [](const int Index) {
		return Columns[Index];
	}

	const Vector& operator [](const int Index) const {
		return Columns[Index];
	}

	Matrix Transpose() const {
		return Matrix(
			Vector(Columns[0].x, Columns[1].x, Columns[2].x),
			Vector(Columns[0].y, Columns[1].y, Columns[2].y),
			Vector(Columns[0].z, Columns[1].z, Columns[2].z)
		);
	}

	Vector operator *(const Vector& Other) const {
		Matrix Temp = Transpose();

		return Vector(
			Temp[0].Dot(Other),
			Temp[1].Dot(Other),
			Temp[2].Dot(Other)
		);
	}

	Matrix operator *(const Matrix& Other) const {
		Matrix Temp = Transpose();

		return Matrix(
			Vector(
				Temp[0].Dot(Other[0]),
				Temp[1].Dot(Other[0]),
				Temp[2].Dot(Other[0])
			),
			Vector(
				Temp[0].Dot(Other[1]),
				Temp[1].Dot(Other[1]),
				Temp[2].Dot(Other[1])
			),
			Vector(
				Temp[0].Dot(Other[2]),
				Temp[1].Dot(Other[2]),
				Temp[2].Dot(Other[2])
			)
		);
	}
};